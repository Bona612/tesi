/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface ERC6956FullInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "allFloating"
      | "anchorByToken"
      | "anchorValid"
      | "approve"
      | "approveAnchor(bytes,bytes)"
      | "approveAnchor(bytes)"
      | "approveAuthorization"
      | "attestationsUsedByAnchor"
      | "balanceOf"
      | "burn"
      | "burnAnchor(bytes)"
      | "burnAnchor(bytes,bytes)"
      | "burnAuthorization"
      | "cidByToken"
      | "createAnchor(bytes,string,bytes)"
      | "createAnchor(bytes,string)"
      | "createAuthorizationMap"
      | "decodeAttestationIfValid"
      | "float"
      | "floatAll"
      | "floatStartAuthorization"
      | "floatStopAuthorization"
      | "floating"
      | "floatingStateByAnchor"
      | "getApproved"
      | "hasAuthorization"
      | "ipfsHashByToken"
      | "isApprovedForAll"
      | "isMaintainer"
      | "isTrustedOracle"
      | "maintainers"
      | "maxAttestationExpireTime"
      | "name"
      | "ownerOf"
      | "safeTransferFrom(address,address,uint256)"
      | "safeTransferFrom(address,address,uint256,bytes)"
      | "setApprovalForAll"
      | "supportsInterface"
      | "symbol"
      | "tokenByAnchor"
      | "tokenByIndex"
      | "tokenOfOwnerByIndex"
      | "tokenURI"
      | "totalSupply"
      | "transferAnchor(bytes)"
      | "transferAnchor(bytes,bytes)"
      | "transferFrom"
      | "updateApproveAuthorization"
      | "updateBaseURI"
      | "updateBurnAuthorization"
      | "updateFloatingAuthorization"
      | "updateMaintainer"
      | "updateOracle"
      | "updateValidAnchors"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AnchorApproval"
      | "AnchorTransfer"
      | "Approval"
      | "ApprovalForAll"
      | "ApproveAuthorizationChange"
      | "AttestationUse"
      | "BurnAuthorizationChange"
      | "FloatingAllStateChange"
      | "FloatingAuthorizationChange"
      | "FloatingStateChange"
      | "OracleUpdate"
      | "Transfer"
      | "ValidAnchorsUpdate"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "allFloating",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "anchorByToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "anchorValid",
    values: [BytesLike, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAnchor(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAnchor(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAuthorization",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "attestationsUsedByAnchor",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "burn", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "burnAnchor(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burnAnchor(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burnAuthorization",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cidByToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createAnchor(bytes,string,bytes)",
    values: [BytesLike, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createAnchor(bytes,string)",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "createAuthorizationMap",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "decodeAttestationIfValid",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "float",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "floatAll", values: [boolean]): string;
  encodeFunctionData(
    functionFragment: "floatStartAuthorization",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "floatStopAuthorization",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "floating", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "floatingStateByAnchor",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "hasAuthorization",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "ipfsHashByToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isMaintainer",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isTrustedOracle",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "maintainers",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "maxAttestationExpireTime",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ownerOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "tokenByAnchor",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenByIndex",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenOfOwnerByIndex",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenURI",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferAnchor(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAnchor(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateApproveAuthorization",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateBaseURI",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateBurnAuthorization",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateFloatingAuthorization",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMaintainer",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateOracle",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateValidAnchors",
    values: [BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "allFloating",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "anchorByToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "anchorValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "approveAnchor(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveAnchor(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestationsUsedByAnchor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "burnAnchor(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "burnAnchor(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "burnAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cidByToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createAnchor(bytes,string,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAnchor(bytes,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAuthorizationMap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decodeAttestationIfValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "float", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "floatAll", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "floatStartAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "floatStopAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "floating", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "floatingStateByAnchor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ipfsHashByToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isMaintainer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTrustedOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maintainers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxAttestationExpireTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "safeTransferFrom(address,address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenByAnchor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenByIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenOfOwnerByIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tokenURI", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAnchor(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAnchor(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateApproveAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateBaseURI",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateBurnAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateFloatingAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMaintainer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateOracle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateValidAnchors",
    data: BytesLike
  ): Result;
}

export namespace AnchorApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    approved: AddressLike,
    anchor: BytesLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    approved: string,
    anchor: string,
    tokenId: bigint
  ];
  export interface OutputObject {
    owner: string;
    approved: string;
    anchor: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AnchorTransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    anchor: BytesLike,
    tokenId: BigNumberish,
    cid: string
  ];
  export type OutputTuple = [
    from: string,
    to: string,
    anchor: string,
    tokenId: bigint,
    cid: string
  ];
  export interface OutputObject {
    from: string;
    to: string;
    anchor: string;
    tokenId: bigint;
    cid: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    approved: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [owner: string, approved: string, tokenId: bigint];
  export interface OutputObject {
    owner: string;
    approved: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ApprovalForAllEvent {
  export type InputTuple = [
    owner: AddressLike,
    operator: AddressLike,
    approved: boolean
  ];
  export type OutputTuple = [
    owner: string,
    operator: string,
    approved: boolean
  ];
  export interface OutputObject {
    owner: string;
    operator: string;
    approved: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ApproveAuthorizationChangeEvent {
  export type InputTuple = [approveAuth: BigNumberish, maintainer: AddressLike];
  export type OutputTuple = [approveAuth: bigint, maintainer: string];
  export interface OutputObject {
    approveAuth: bigint;
    maintainer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AttestationUseEvent {
  export type InputTuple = [
    to: AddressLike,
    anchor: BytesLike,
    attestationHash: BytesLike,
    totalUsedAttestationsForAnchor: BigNumberish
  ];
  export type OutputTuple = [
    to: string,
    anchor: string,
    attestationHash: string,
    totalUsedAttestationsForAnchor: bigint
  ];
  export interface OutputObject {
    to: string;
    anchor: string;
    attestationHash: string;
    totalUsedAttestationsForAnchor: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BurnAuthorizationChangeEvent {
  export type InputTuple = [burnAuth: BigNumberish, maintainer: AddressLike];
  export type OutputTuple = [burnAuth: bigint, maintainer: string];
  export interface OutputObject {
    burnAuth: bigint;
    maintainer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FloatingAllStateChangeEvent {
  export type InputTuple = [areFloating: boolean, operator: AddressLike];
  export type OutputTuple = [areFloating: boolean, operator: string];
  export interface OutputObject {
    areFloating: boolean;
    operator: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FloatingAuthorizationChangeEvent {
  export type InputTuple = [
    startAuthorization: BigNumberish,
    stopAuthorization: BigNumberish,
    maintainer: AddressLike
  ];
  export type OutputTuple = [
    startAuthorization: bigint,
    stopAuthorization: bigint,
    maintainer: string
  ];
  export interface OutputObject {
    startAuthorization: bigint;
    stopAuthorization: bigint;
    maintainer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FloatingStateChangeEvent {
  export type InputTuple = [
    anchor: BytesLike,
    tokenId: BigNumberish,
    isFloating: BigNumberish,
    operator: AddressLike
  ];
  export type OutputTuple = [
    anchor: string,
    tokenId: bigint,
    isFloating: bigint,
    operator: string
  ];
  export interface OutputObject {
    anchor: string;
    tokenId: bigint;
    isFloating: bigint;
    operator: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OracleUpdateEvent {
  export type InputTuple = [oracle: AddressLike, trusted: boolean];
  export type OutputTuple = [oracle: string, trusted: boolean];
  export interface OutputObject {
    oracle: string;
    trusted: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, tokenId: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ValidAnchorsUpdateEvent {
  export type InputTuple = [
    validAnchorHash: BytesLike,
    maintainer: AddressLike
  ];
  export type OutputTuple = [validAnchorHash: string, maintainer: string];
  export interface OutputObject {
    validAnchorHash: string;
    maintainer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ERC6956Full extends BaseContract {
  connect(runner?: ContractRunner | null): ERC6956Full;
  waitForDeployment(): Promise<this>;

  interface: ERC6956FullInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allFloating: TypedContractMethod<[], [boolean], "view">;

  anchorByToken: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  anchorValid: TypedContractMethod<
    [anchor: BytesLike, proof: BytesLike[]],
    [boolean],
    "view"
  >;

  approve: TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;

  "approveAnchor(bytes,bytes)": TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  "approveAnchor(bytes)": TypedContractMethod<
    [attestation: BytesLike],
    [void],
    "nonpayable"
  >;

  approveAuthorization: TypedContractMethod<[], [bigint], "view">;

  attestationsUsedByAnchor: TypedContractMethod<
    [arg0: BytesLike],
    [bigint],
    "view"
  >;

  balanceOf: TypedContractMethod<[owner: AddressLike], [bigint], "view">;

  burn: TypedContractMethod<[tokenId: BigNumberish], [void], "nonpayable">;

  "burnAnchor(bytes)": TypedContractMethod<
    [attestation: BytesLike],
    [void],
    "nonpayable"
  >;

  "burnAnchor(bytes,bytes)": TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  burnAuthorization: TypedContractMethod<[], [bigint], "view">;

  cidByToken: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  "createAnchor(bytes,string,bytes)": TypedContractMethod<
    [attestation: BytesLike, cid: string, data: BytesLike],
    [void],
    "nonpayable"
  >;

  "createAnchor(bytes,string)": TypedContractMethod<
    [attestation: BytesLike, cid: string],
    [void],
    "nonpayable"
  >;

  createAuthorizationMap: TypedContractMethod<
    [_auth: BigNumberish],
    [bigint],
    "view"
  >;

  decodeAttestationIfValid: TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [
      [string, string, string] & {
        to: string;
        anchor: string;
        attestationHash: string;
      }
    ],
    "view"
  >;

  float: TypedContractMethod<
    [anchor: BytesLike, newFloatState: BigNumberish],
    [void],
    "nonpayable"
  >;

  floatAll: TypedContractMethod<[doFloatAll: boolean], [void], "nonpayable">;

  floatStartAuthorization: TypedContractMethod<[], [bigint], "view">;

  floatStopAuthorization: TypedContractMethod<[], [bigint], "view">;

  floating: TypedContractMethod<[anchor: BytesLike], [boolean], "view">;

  floatingStateByAnchor: TypedContractMethod<
    [arg0: BytesLike],
    [bigint],
    "view"
  >;

  getApproved: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  hasAuthorization: TypedContractMethod<
    [_role: BigNumberish, _auth: BigNumberish],
    [boolean],
    "view"
  >;

  ipfsHashByToken: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  isApprovedForAll: TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;

  isMaintainer: TypedContractMethod<[a: AddressLike], [boolean], "view">;

  isTrustedOracle: TypedContractMethod<
    [oracleAddress: AddressLike],
    [boolean],
    "view"
  >;

  maintainers: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  maxAttestationExpireTime: TypedContractMethod<[], [bigint], "view">;

  name: TypedContractMethod<[], [string], "view">;

  ownerOf: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  "safeTransferFrom(address,address,uint256)": TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;

  "safeTransferFrom(address,address,uint256,bytes)": TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  setApprovalForAll: TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  symbol: TypedContractMethod<[], [string], "view">;

  tokenByAnchor: TypedContractMethod<[arg0: BytesLike], [bigint], "view">;

  tokenByIndex: TypedContractMethod<[index: BigNumberish], [bigint], "view">;

  tokenOfOwnerByIndex: TypedContractMethod<
    [owner: AddressLike, index: BigNumberish],
    [bigint],
    "view"
  >;

  tokenURI: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  "transferAnchor(bytes)": TypedContractMethod<
    [attestation: BytesLike],
    [void],
    "nonpayable"
  >;

  "transferAnchor(bytes,bytes)": TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;

  updateApproveAuthorization: TypedContractMethod<
    [approveAuth: BigNumberish],
    [void],
    "nonpayable"
  >;

  updateBaseURI: TypedContractMethod<
    [tokenBaseURI: string],
    [void],
    "nonpayable"
  >;

  updateBurnAuthorization: TypedContractMethod<
    [burnAuth: BigNumberish],
    [void],
    "nonpayable"
  >;

  updateFloatingAuthorization: TypedContractMethod<
    [startAuthorization: BigNumberish, stopAuthorization: BigNumberish],
    [void],
    "nonpayable"
  >;

  updateMaintainer: TypedContractMethod<
    [_maintainer: AddressLike, _add: boolean],
    [void],
    "nonpayable"
  >;

  updateOracle: TypedContractMethod<
    [oracle: AddressLike, doTrust: boolean],
    [void],
    "nonpayable"
  >;

  updateValidAnchors: TypedContractMethod<
    [merkleRootNode: BytesLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allFloating"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "anchorByToken"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "anchorValid"
  ): TypedContractMethod<
    [anchor: BytesLike, proof: BytesLike[]],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveAnchor(bytes,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveAnchor(bytes)"
  ): TypedContractMethod<[attestation: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "approveAuthorization"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "attestationsUsedByAnchor"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[owner: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "burn"
  ): TypedContractMethod<[tokenId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "burnAnchor(bytes)"
  ): TypedContractMethod<[attestation: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "burnAnchor(bytes,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "burnAuthorization"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "cidByToken"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "createAnchor(bytes,string,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, cid: string, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createAnchor(bytes,string)"
  ): TypedContractMethod<
    [attestation: BytesLike, cid: string],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createAuthorizationMap"
  ): TypedContractMethod<[_auth: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "decodeAttestationIfValid"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [
      [string, string, string] & {
        to: string;
        anchor: string;
        attestationHash: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "float"
  ): TypedContractMethod<
    [anchor: BytesLike, newFloatState: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "floatAll"
  ): TypedContractMethod<[doFloatAll: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "floatStartAuthorization"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "floatStopAuthorization"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "floating"
  ): TypedContractMethod<[anchor: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "floatingStateByAnchor"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getApproved"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "hasAuthorization"
  ): TypedContractMethod<
    [_role: BigNumberish, _auth: BigNumberish],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "ipfsHashByToken"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "isMaintainer"
  ): TypedContractMethod<[a: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isTrustedOracle"
  ): TypedContractMethod<[oracleAddress: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "maintainers"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "maxAttestationExpireTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "ownerOf"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "safeTransferFrom(address,address,uint256)"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "safeTransferFrom(address,address,uint256,bytes)"
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setApprovalForAll"
  ): TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "tokenByAnchor"
  ): TypedContractMethod<[arg0: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "tokenByIndex"
  ): TypedContractMethod<[index: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "tokenOfOwnerByIndex"
  ): TypedContractMethod<
    [owner: AddressLike, index: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "tokenURI"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferAnchor(bytes)"
  ): TypedContractMethod<[attestation: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferAnchor(bytes,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateApproveAuthorization"
  ): TypedContractMethod<[approveAuth: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateBaseURI"
  ): TypedContractMethod<[tokenBaseURI: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateBurnAuthorization"
  ): TypedContractMethod<[burnAuth: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "updateFloatingAuthorization"
  ): TypedContractMethod<
    [startAuthorization: BigNumberish, stopAuthorization: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateMaintainer"
  ): TypedContractMethod<
    [_maintainer: AddressLike, _add: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateOracle"
  ): TypedContractMethod<
    [oracle: AddressLike, doTrust: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateValidAnchors"
  ): TypedContractMethod<[merkleRootNode: BytesLike], [void], "nonpayable">;

  getEvent(
    key: "AnchorApproval"
  ): TypedContractEvent<
    AnchorApprovalEvent.InputTuple,
    AnchorApprovalEvent.OutputTuple,
    AnchorApprovalEvent.OutputObject
  >;
  getEvent(
    key: "AnchorTransfer"
  ): TypedContractEvent<
    AnchorTransferEvent.InputTuple,
    AnchorTransferEvent.OutputTuple,
    AnchorTransferEvent.OutputObject
  >;
  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "ApprovalForAll"
  ): TypedContractEvent<
    ApprovalForAllEvent.InputTuple,
    ApprovalForAllEvent.OutputTuple,
    ApprovalForAllEvent.OutputObject
  >;
  getEvent(
    key: "ApproveAuthorizationChange"
  ): TypedContractEvent<
    ApproveAuthorizationChangeEvent.InputTuple,
    ApproveAuthorizationChangeEvent.OutputTuple,
    ApproveAuthorizationChangeEvent.OutputObject
  >;
  getEvent(
    key: "AttestationUse"
  ): TypedContractEvent<
    AttestationUseEvent.InputTuple,
    AttestationUseEvent.OutputTuple,
    AttestationUseEvent.OutputObject
  >;
  getEvent(
    key: "BurnAuthorizationChange"
  ): TypedContractEvent<
    BurnAuthorizationChangeEvent.InputTuple,
    BurnAuthorizationChangeEvent.OutputTuple,
    BurnAuthorizationChangeEvent.OutputObject
  >;
  getEvent(
    key: "FloatingAllStateChange"
  ): TypedContractEvent<
    FloatingAllStateChangeEvent.InputTuple,
    FloatingAllStateChangeEvent.OutputTuple,
    FloatingAllStateChangeEvent.OutputObject
  >;
  getEvent(
    key: "FloatingAuthorizationChange"
  ): TypedContractEvent<
    FloatingAuthorizationChangeEvent.InputTuple,
    FloatingAuthorizationChangeEvent.OutputTuple,
    FloatingAuthorizationChangeEvent.OutputObject
  >;
  getEvent(
    key: "FloatingStateChange"
  ): TypedContractEvent<
    FloatingStateChangeEvent.InputTuple,
    FloatingStateChangeEvent.OutputTuple,
    FloatingStateChangeEvent.OutputObject
  >;
  getEvent(
    key: "OracleUpdate"
  ): TypedContractEvent<
    OracleUpdateEvent.InputTuple,
    OracleUpdateEvent.OutputTuple,
    OracleUpdateEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;
  getEvent(
    key: "ValidAnchorsUpdate"
  ): TypedContractEvent<
    ValidAnchorsUpdateEvent.InputTuple,
    ValidAnchorsUpdateEvent.OutputTuple,
    ValidAnchorsUpdateEvent.OutputObject
  >;

  filters: {
    "AnchorApproval(address,address,bytes32,uint256)": TypedContractEvent<
      AnchorApprovalEvent.InputTuple,
      AnchorApprovalEvent.OutputTuple,
      AnchorApprovalEvent.OutputObject
    >;
    AnchorApproval: TypedContractEvent<
      AnchorApprovalEvent.InputTuple,
      AnchorApprovalEvent.OutputTuple,
      AnchorApprovalEvent.OutputObject
    >;

    "AnchorTransfer(address,address,bytes32,uint256,string)": TypedContractEvent<
      AnchorTransferEvent.InputTuple,
      AnchorTransferEvent.OutputTuple,
      AnchorTransferEvent.OutputObject
    >;
    AnchorTransfer: TypedContractEvent<
      AnchorTransferEvent.InputTuple,
      AnchorTransferEvent.OutputTuple,
      AnchorTransferEvent.OutputObject
    >;

    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "ApprovalForAll(address,address,bool)": TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;
    ApprovalForAll: TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >;

    "ApproveAuthorizationChange(uint8,address)": TypedContractEvent<
      ApproveAuthorizationChangeEvent.InputTuple,
      ApproveAuthorizationChangeEvent.OutputTuple,
      ApproveAuthorizationChangeEvent.OutputObject
    >;
    ApproveAuthorizationChange: TypedContractEvent<
      ApproveAuthorizationChangeEvent.InputTuple,
      ApproveAuthorizationChangeEvent.OutputTuple,
      ApproveAuthorizationChangeEvent.OutputObject
    >;

    "AttestationUse(address,bytes32,bytes32,uint256)": TypedContractEvent<
      AttestationUseEvent.InputTuple,
      AttestationUseEvent.OutputTuple,
      AttestationUseEvent.OutputObject
    >;
    AttestationUse: TypedContractEvent<
      AttestationUseEvent.InputTuple,
      AttestationUseEvent.OutputTuple,
      AttestationUseEvent.OutputObject
    >;

    "BurnAuthorizationChange(uint8,address)": TypedContractEvent<
      BurnAuthorizationChangeEvent.InputTuple,
      BurnAuthorizationChangeEvent.OutputTuple,
      BurnAuthorizationChangeEvent.OutputObject
    >;
    BurnAuthorizationChange: TypedContractEvent<
      BurnAuthorizationChangeEvent.InputTuple,
      BurnAuthorizationChangeEvent.OutputTuple,
      BurnAuthorizationChangeEvent.OutputObject
    >;

    "FloatingAllStateChange(bool,address)": TypedContractEvent<
      FloatingAllStateChangeEvent.InputTuple,
      FloatingAllStateChangeEvent.OutputTuple,
      FloatingAllStateChangeEvent.OutputObject
    >;
    FloatingAllStateChange: TypedContractEvent<
      FloatingAllStateChangeEvent.InputTuple,
      FloatingAllStateChangeEvent.OutputTuple,
      FloatingAllStateChangeEvent.OutputObject
    >;

    "FloatingAuthorizationChange(uint8,uint8,address)": TypedContractEvent<
      FloatingAuthorizationChangeEvent.InputTuple,
      FloatingAuthorizationChangeEvent.OutputTuple,
      FloatingAuthorizationChangeEvent.OutputObject
    >;
    FloatingAuthorizationChange: TypedContractEvent<
      FloatingAuthorizationChangeEvent.InputTuple,
      FloatingAuthorizationChangeEvent.OutputTuple,
      FloatingAuthorizationChangeEvent.OutputObject
    >;

    "FloatingStateChange(bytes32,uint256,uint8,address)": TypedContractEvent<
      FloatingStateChangeEvent.InputTuple,
      FloatingStateChangeEvent.OutputTuple,
      FloatingStateChangeEvent.OutputObject
    >;
    FloatingStateChange: TypedContractEvent<
      FloatingStateChangeEvent.InputTuple,
      FloatingStateChangeEvent.OutputTuple,
      FloatingStateChangeEvent.OutputObject
    >;

    "OracleUpdate(address,bool)": TypedContractEvent<
      OracleUpdateEvent.InputTuple,
      OracleUpdateEvent.OutputTuple,
      OracleUpdateEvent.OutputObject
    >;
    OracleUpdate: TypedContractEvent<
      OracleUpdateEvent.InputTuple,
      OracleUpdateEvent.OutputTuple,
      OracleUpdateEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;

    "ValidAnchorsUpdate(bytes32,address)": TypedContractEvent<
      ValidAnchorsUpdateEvent.InputTuple,
      ValidAnchorsUpdateEvent.OutputTuple,
      ValidAnchorsUpdateEvent.OutputObject
    >;
    ValidAnchorsUpdate: TypedContractEvent<
      ValidAnchorsUpdateEvent.InputTuple,
      ValidAnchorsUpdateEvent.OutputTuple,
      ValidAnchorsUpdateEvent.OutputObject
    >;
  };
}
