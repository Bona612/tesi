/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface IERC6956ValidAnchorsInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "anchorByToken"
      | "anchorValid"
      | "approveAnchor(bytes,bytes)"
      | "approveAnchor(bytes)"
      | "approveAuthorization"
      | "attestationsUsedByAnchor"
      | "burnAnchor(bytes)"
      | "burnAnchor(bytes,bytes)"
      | "burnAuthorization"
      | "createAnchor(bytes,string,bytes)"
      | "createAnchor(bytes,string)"
      | "decodeAttestationIfValid"
      | "tokenByAnchor"
      | "transferAnchor(bytes)"
      | "transferAnchor(bytes,bytes)"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AnchorApproval"
      | "AnchorTransfer"
      | "AttestationUse"
      | "OracleUpdate"
      | "ValidAnchorsUpdate"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "anchorByToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "anchorValid",
    values: [BytesLike, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAnchor(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAnchor(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAuthorization",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "attestationsUsedByAnchor",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burnAnchor(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burnAnchor(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burnAuthorization",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "createAnchor(bytes,string,bytes)",
    values: [BytesLike, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createAnchor(bytes,string)",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "decodeAttestationIfValid",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenByAnchor",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAnchor(bytes)",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAnchor(bytes,bytes)",
    values: [BytesLike, BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "anchorByToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "anchorValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveAnchor(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveAnchor(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "attestationsUsedByAnchor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "burnAnchor(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "burnAnchor(bytes,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "burnAuthorization",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAnchor(bytes,string,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createAnchor(bytes,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decodeAttestationIfValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenByAnchor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAnchor(bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAnchor(bytes,bytes)",
    data: BytesLike
  ): Result;
}

export namespace AnchorApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    approved: AddressLike,
    anchor: BytesLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    approved: string,
    anchor: string,
    tokenId: bigint
  ];
  export interface OutputObject {
    owner: string;
    approved: string;
    anchor: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AnchorTransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    anchor: BytesLike,
    tokenId: BigNumberish,
    cid: string
  ];
  export type OutputTuple = [
    from: string,
    to: string,
    anchor: string,
    tokenId: bigint,
    cid: string
  ];
  export interface OutputObject {
    from: string;
    to: string;
    anchor: string;
    tokenId: bigint;
    cid: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AttestationUseEvent {
  export type InputTuple = [
    to: AddressLike,
    anchor: BytesLike,
    attestationHash: BytesLike,
    totalUsedAttestationsForAnchor: BigNumberish
  ];
  export type OutputTuple = [
    to: string,
    anchor: string,
    attestationHash: string,
    totalUsedAttestationsForAnchor: bigint
  ];
  export interface OutputObject {
    to: string;
    anchor: string;
    attestationHash: string;
    totalUsedAttestationsForAnchor: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OracleUpdateEvent {
  export type InputTuple = [oracle: AddressLike, trusted: boolean];
  export type OutputTuple = [oracle: string, trusted: boolean];
  export interface OutputObject {
    oracle: string;
    trusted: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ValidAnchorsUpdateEvent {
  export type InputTuple = [
    validAnchorHash: BytesLike,
    maintainer: AddressLike
  ];
  export type OutputTuple = [validAnchorHash: string, maintainer: string];
  export interface OutputObject {
    validAnchorHash: string;
    maintainer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IERC6956ValidAnchors extends BaseContract {
  connect(runner?: ContractRunner | null): IERC6956ValidAnchors;
  waitForDeployment(): Promise<this>;

  interface: IERC6956ValidAnchorsInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  anchorByToken: TypedContractMethod<[tokenId: BigNumberish], [string], "view">;

  anchorValid: TypedContractMethod<
    [anchor: BytesLike, proof: BytesLike[]],
    [boolean],
    "view"
  >;

  "approveAnchor(bytes,bytes)": TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  "approveAnchor(bytes)": TypedContractMethod<
    [attestation: BytesLike],
    [void],
    "nonpayable"
  >;

  approveAuthorization: TypedContractMethod<[], [bigint], "view">;

  attestationsUsedByAnchor: TypedContractMethod<
    [anchor: BytesLike],
    [bigint],
    "view"
  >;

  "burnAnchor(bytes)": TypedContractMethod<
    [attestation: BytesLike],
    [void],
    "nonpayable"
  >;

  "burnAnchor(bytes,bytes)": TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  burnAuthorization: TypedContractMethod<[], [bigint], "view">;

  "createAnchor(bytes,string,bytes)": TypedContractMethod<
    [attestation: BytesLike, cid: string, data: BytesLike],
    [void],
    "nonpayable"
  >;

  "createAnchor(bytes,string)": TypedContractMethod<
    [attestation: BytesLike, cid: string],
    [void],
    "nonpayable"
  >;

  decodeAttestationIfValid: TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [
      [string, string, string] & {
        to: string;
        anchor: string;
        attestationHash: string;
      }
    ],
    "view"
  >;

  tokenByAnchor: TypedContractMethod<[anchor: BytesLike], [bigint], "view">;

  "transferAnchor(bytes)": TypedContractMethod<
    [attestation: BytesLike],
    [void],
    "nonpayable"
  >;

  "transferAnchor(bytes,bytes)": TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "anchorByToken"
  ): TypedContractMethod<[tokenId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "anchorValid"
  ): TypedContractMethod<
    [anchor: BytesLike, proof: BytesLike[]],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "approveAnchor(bytes,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveAnchor(bytes)"
  ): TypedContractMethod<[attestation: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "approveAuthorization"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "attestationsUsedByAnchor"
  ): TypedContractMethod<[anchor: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "burnAnchor(bytes)"
  ): TypedContractMethod<[attestation: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "burnAnchor(bytes,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "burnAuthorization"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "createAnchor(bytes,string,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, cid: string, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createAnchor(bytes,string)"
  ): TypedContractMethod<
    [attestation: BytesLike, cid: string],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "decodeAttestationIfValid"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [
      [string, string, string] & {
        to: string;
        anchor: string;
        attestationHash: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "tokenByAnchor"
  ): TypedContractMethod<[anchor: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferAnchor(bytes)"
  ): TypedContractMethod<[attestation: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferAnchor(bytes,bytes)"
  ): TypedContractMethod<
    [attestation: BytesLike, data: BytesLike],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "AnchorApproval"
  ): TypedContractEvent<
    AnchorApprovalEvent.InputTuple,
    AnchorApprovalEvent.OutputTuple,
    AnchorApprovalEvent.OutputObject
  >;
  getEvent(
    key: "AnchorTransfer"
  ): TypedContractEvent<
    AnchorTransferEvent.InputTuple,
    AnchorTransferEvent.OutputTuple,
    AnchorTransferEvent.OutputObject
  >;
  getEvent(
    key: "AttestationUse"
  ): TypedContractEvent<
    AttestationUseEvent.InputTuple,
    AttestationUseEvent.OutputTuple,
    AttestationUseEvent.OutputObject
  >;
  getEvent(
    key: "OracleUpdate"
  ): TypedContractEvent<
    OracleUpdateEvent.InputTuple,
    OracleUpdateEvent.OutputTuple,
    OracleUpdateEvent.OutputObject
  >;
  getEvent(
    key: "ValidAnchorsUpdate"
  ): TypedContractEvent<
    ValidAnchorsUpdateEvent.InputTuple,
    ValidAnchorsUpdateEvent.OutputTuple,
    ValidAnchorsUpdateEvent.OutputObject
  >;

  filters: {
    "AnchorApproval(address,address,bytes32,uint256)": TypedContractEvent<
      AnchorApprovalEvent.InputTuple,
      AnchorApprovalEvent.OutputTuple,
      AnchorApprovalEvent.OutputObject
    >;
    AnchorApproval: TypedContractEvent<
      AnchorApprovalEvent.InputTuple,
      AnchorApprovalEvent.OutputTuple,
      AnchorApprovalEvent.OutputObject
    >;

    "AnchorTransfer(address,address,bytes32,uint256,string)": TypedContractEvent<
      AnchorTransferEvent.InputTuple,
      AnchorTransferEvent.OutputTuple,
      AnchorTransferEvent.OutputObject
    >;
    AnchorTransfer: TypedContractEvent<
      AnchorTransferEvent.InputTuple,
      AnchorTransferEvent.OutputTuple,
      AnchorTransferEvent.OutputObject
    >;

    "AttestationUse(address,bytes32,bytes32,uint256)": TypedContractEvent<
      AttestationUseEvent.InputTuple,
      AttestationUseEvent.OutputTuple,
      AttestationUseEvent.OutputObject
    >;
    AttestationUse: TypedContractEvent<
      AttestationUseEvent.InputTuple,
      AttestationUseEvent.OutputTuple,
      AttestationUseEvent.OutputObject
    >;

    "OracleUpdate(address,bool)": TypedContractEvent<
      OracleUpdateEvent.InputTuple,
      OracleUpdateEvent.OutputTuple,
      OracleUpdateEvent.OutputObject
    >;
    OracleUpdate: TypedContractEvent<
      OracleUpdateEvent.InputTuple,
      OracleUpdateEvent.OutputTuple,
      OracleUpdateEvent.OutputObject
    >;

    "ValidAnchorsUpdate(bytes32,address)": TypedContractEvent<
      ValidAnchorsUpdateEvent.InputTuple,
      ValidAnchorsUpdateEvent.OutputTuple,
      ValidAnchorsUpdateEvent.OutputObject
    >;
    ValidAnchorsUpdate: TypedContractEvent<
      ValidAnchorsUpdateEvent.InputTuple,
      ValidAnchorsUpdateEvent.OutputTuple,
      ValidAnchorsUpdateEvent.OutputObject
    >;
  };
}
